<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - Manage Images</title>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="../css/admin.css">
      <style>

    </style>
</head>
<body>
    
<!-- CSS for Styling -->
<style>
    #imageUploadArea.dragging {
        border-color: #007bff;
        background-color: #f8f9fa;
    }
    .loading-spinner .spinner-border {
        margin-top: 2rem;
    }
    .progress-bar {
        transition: width 0.4s ease;
    }

    /* Basic modal styling */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
}

.modal-dialog {
    max-width: 90%;
    margin: auto;
    overflow-y: auto;
    height: 100%;
}
#imageCanvas {
    width: 100%; /* Make canvas responsive */
    height: auto;
}

.editor-controls {
    display: flex;
    flex-direction: column;
}
/* Styles specifically for input elements of type range and number inside watermarkSettingsModal */
#watermarkSettingsModal input[type="range"], 
#watermarkSettingsModal input[type="number"], 

/* Styles specifically for input elements of type range and number inside imageEditorModal */
#imageEditorModal input[type="range"], 
#imageEditorModal input[type="number"] {
    max-width: 75px;      /* Limits the maximum width of the input */
    min-width: 50px;      /* Prevents the input from shrinking smaller than 50px */
    width: 100%;          /* Makes the input take up the full width of its container */
    box-sizing: border-box; /* Includes padding and border in the width calculation */
}

select, input[type="range"], input[type="number"] {
            margin-bottom: 10px;
        }
        .slider_editor {
            display: none; /* Start hidden */
            margin-bottom: 20px;
        }
        .visible {
            display: block; /* Show when needed */
        }
        .close {
   max-width: 20%;
    font-size: 2rem;
}

#watermark-holder {
    /* display: flex; */
    margin: auto;
    position: relative;
}

#watermarkCanvas-holder {
    display: block;
    width: auto;
    position: relative;
    margin: auto;
    width: 400px;
    height: 200px;

}

#watermarkZoom-holder {
    display: block;
    width: 200px;
    transform: rotate(270deg);
    position: absolute;
    /* bottom: 0; */
    /* left: 0; */
    /* top: 0; */
    height: 20px;
    top: 95px;
    left: 325px;
}

#watermarkScale {
    display: block;
    position: relative;
    width: 200px !important;
    min-width: 200px !important;
    height: 10px !important;
    min-height: 10px !important;
    padding: 8px !important;
}

</style>
    <header class="admin-header">
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <a class="navbar-brand" href="#">Manage Images & Events</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="../admin/dashboard">Dashboard</a></li>
                    <li class="nav-item"><a class="nav-link" href="design.html">Design</a></li>
                    <li class="nav-item"><a class="nav-link" href="images.html">Images</a></li>
                    <li class="nav-item"><a class="nav-link" href="analytics.html">Analytics</a></li>
                    <li class="nav-item"><a class="nav-link" href="purchases.html">Purchases</a></li>
                    <li class="nav-item"><a class="nav-link" href="appointments.html">Appointments</a></li>
                    <li class="nav-item"><a class="nav-link" href="settings.html">Settings</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <!-- Header -->
    <header class="bg-dark text-white p-3 mb-4">
        <div class="container">
            <h1 class="text-center">Admin Dashboard - Manage Images & Events</h1>
            <nav>
                <a href="home.html" class="text-white mx-3">Home</a>
                <a href="manage-events.html" class="text-white mx-3">Manage Events</a>
                <a href="manage-images.html" class="text-white mx-3">Manage Images</a>
                <a id="logoutBtn"  href="/" class="text-white mx-3">Logout</a>
            </nav>
        </div>
    </header>
    <div class="container-fluid admin-container">


        <main class="dashboard-content">
            <p class="text-muted">Use this panel to manage images and events. Upload images, set prices, and save details. Please ensure all information is correct before saving.</p>
        
            <div class="container mt-5">
                <h1 class="text-center">Manage Images and Events</h1>
        
                <!-- Event Information Section -->
                <section class="my-4">
                    <h2>Add Event Details</h2>
                    <form id="eventForm">
                        <div class="form-row">
                            <div class="form-group col-md-6">
                                <label for="eventTitle">Event Title</label>
                                <input type="text" class="form-control" id="eventTitle" placeholder="Event Title" required>
                            </div>
                            <div class="form-group col-md-6">
                                <label for="eventDate">Event Date</label>
                                <input type="date" class="form-control" id="eventDate" required>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="eventDescription">Event Description</label>
                            <textarea class="form-control" id="eventDescription" rows="3" placeholder="Event Description"></textarea>
                        </div>
                        <div class="form-row">
                            <div class="form-group col-md-6">
                                <label for="eventPrice">Base Price (USD)</label>
                                <input type="number" class="form-control" id="eventPrice" placeholder="Event Price" required>
                            </div>
                            <div class="form-group col-md-6">
                                <label for="accessCode">Access Code</label>
                                <input type="text" class="form-control" id="accessCode" placeholder="Enter Access Code">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="eventLocation">Event Location</label>
                            <input type="text" class="form-control" id="eventLocation" placeholder="Event Location" required>
                        </div>
                        <button id="saveEvent" type="button" class="btn btn-primary" >Save Event</button>
                    </form>
                </section>
        
                <!-- Image Upload Section -->
                <section class="my-4">
                    <h2>Upload Images</h2>
                    <div id="imageUploadArea" class="border border-primary p-4 text-center" >
                        <p>Drag and drop images here or click to upload</p>
                        <input type="file" id="imageInput" multiple accept="image/*" style="display: none;" >
                    </div>

        <!-- Button to open watermark settings -->
<button id="watermarkSettingsBtn" class="btn btn-primary">Edit Watermark</button>
<!-- Button to open the image editor --> 
<button id="openImageEditorBtn" class="btn btn-primary">Open Image Editor</button>
                    
<style>
/* Responsive Styles */
@media (min-width:  700px) {
    .watermarkSettingsFooter  {
        display: grid;
    }
}

@media (max-width:  700px) {
    .watermarkSettingsFooter  {
        display: flex;
    }
}
    /* Progress Bar Styles */
.progress {
    height: 30px; /* Adjust height */
    border-radius: 5px; /* Rounded corners */
    background: linear-gradient(45deg, #1a237e, #3f51b5); /* Light background */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    overflow: hidden; /* Prevents overflow */
}

.progress-bar {
    background-color: #007bff; /* Primary color for progress */
    transition: width 0.4s ease; /* Smooth transition effect */
    color: white; /* Text color inside the progress bar */
    font-weight: bold; /* Make text bold */
    text-align: center; /* Center the text */
    line-height: 30px; /* Center the text vertically */
}

#watermarkPreviewCanvas {
    border: 1px solid #ccc;
    display: block;
    margin: auto;

}

#imageCanvas {
    border: 1px solid #ccc;
    display: block;
    margin: auto;
    background-color: #ffffffa2;

}

#uploadLogo {
    display: none;
}

</style>


<!-- Progress Bar -->
                    <div class="progress mt-3" id="uploadProgressBar" style="display: none;">
                        <div class="progress-bar" id="uploadProgress" role="progressbar" style="width: 0%;" aria-valuemin="0" aria-valuemax="100">0%</div>
                    </div>
                    
                    <!-- imagePreviewContainer -->

                    <div id="imageGallery" class="row mt-3"></div>
                    <div id="imagePreviewContainer" class="row mt-3"></div>
                    <button id="saveImagesBtn" type="button" class="btn btn-success mt-3" >Save Images</button>
                    <button id="saveAllImagesBtn" type="button" class="btn btn-success mt-1" >Save All Images</button>
                </section>
            </div>
        
            <!-- Loading Spinner -->
            <div class="loading-spinner text-center" style="display: none;">
                <div class="spinner-border" role="status">
                    <span class="sr-only">Loading...</span>
                </div>
            </div>




            <section id="Watermark settings modal-Section">
<!-- Watermark settings modal -->
<div id="watermarkSettingsModal" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Watermark Settings</h5>
                <button id="closeWatermarkX" type="button" class="close" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">




                <div class="container-fluid d-flex mb-4">
                <!-- Watermark preview canvas -->

                <div id="watermark-holder">
                <div id="watermarkCanvas-holder">
                <canvas id="watermarkPreviewCanvas" width="400" height="200" style="border:1px solid #ccc;"></canvas>
            </div>

            <div id="watermarkZoom-holder">
                    <input  class="ml-1 custom-slider"
                        type="range" 
                        id="watermarkScale" 
                        min="0" 
                        max="5" 
                        step="1" 
                        value="1"
                        style=" width: 200px !important;" >
                
                </div>
            </div>
        </div>


        <div class="watermark-controls container-fluid d-grid">

                <div class="container-fluid d-flex">
                            <div class="container-fluid">

                <!-- Watermark input fields -->
                <label for="watermarkText">Text</label>
                <input type="text" id="watermarkText" class="form-control" placeholder="Enter watermark text">
               
            </div>
            <div class="container-fluid">
                <label for="watermarkFont">Font</label>
                <select id="watermarkFont" class="form-control">
                    <option value="Arial Black">Arial Black</option>
                    <option value="Arial">Arial</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Verdana">Verdana</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Tahoma">Tahoma</option>
                    <option value="Trebuchet MS">Trebuchet MS</option>
                    <option value="Comic Sans MS">Comic Sans MS</option>
                    <option value="Lucida Console">Lucida Console</option>
                    <option value="Impact">Impact</option>
                    <option value="Palatino">Palatino</option>
                    <option value="Consolas">Consolas</option>
                </select>
            </div>
            <div class="container-fluid">
                <label for="watermarkSize">Font Size</label>
                <input type="number" id="watermarkSize" class="form-control" placeholder="240" value="240">
            </div>
        </div>
               
            <div class="container-fluid d-flex">

                <div class="container-fluid">
                <label class="custom-checkbox-container">
                    <span class="custom-checkbox-label">Multiple Watermarks</span>
                </label>
                    <input type="checkbox" id="multipleWaterMark" class="custom-checkbox">
                 </div>

          <!-- Bold and Underline Toggle Buttons -->
<div class="container-fluid">
    <label class="custom-checkbox-container">
        <span class="custom-checkbox-label">Underline</span>
    </label>
        <input type="checkbox" id="watermarkUnderline" class="custom-checkbox">
</div>
<div class="container-fluid">
    <label class="custom-checkbox-container">
        <span class="custom-checkbox-label">Bold</span>
    </label> 
        <input type="checkbox" id="watermarkBold" class="custom-checkbox">
     </div>

                <div class="container-fluid">
                <label for="watermarkColor">Color</label>
                <input type="color" id="watermarkColor" class="form-control" value="#000000">
            </div>
            <div class="container-fluid">
                <label for="watermarkOpacity">Opacity</label>
                <input type="range" id="watermarkOpacity" class="form-control custom-slider" min="0" max="1" step="0.1" value="0.5">
            </div>

    

        </div>

               <div class="container-fluid d-flex">
                    <div class="container-fluid">
                        <!-- Add Stroke Width Dropdown -->
            <label for="watermarkStroke">Stroke Width:</label>
            <select id="watermarkStroke">
                <option value="1">Thin</option>
                <option value="2">Medium</option>
                <option value="3">Bold</option>
            </select>
            </div>

            <div class="container-fluid">
                <label for="watermarkRotation">Rotation (degrees)</label>
                <input type="number" id="watermarkRotation" class="form-control" placeholder="0" value="0">
            </div>
            <div class="container-fluid">
                <label for="watermarkPositionX">Position X</label>
                <input type="number" id="watermarkPositionX" class="form-control" placeholder="95" value="95">
            </div>
            <div class="container-fluid">
                <label for="watermarkPositionY">Position Y</label>
                <input type="number" id="watermarkPositionY" class="form-control" placeholder="140" value="140">
            </div>
        </div>
    </div>
</div>

        <div class="watermarkSettingsFooter modal-footer">
            <button id="resetWatermarkSettings" type="button" class="btn btn-secondary">Reset</button>
            <button id="applyWatermarkSettings" type="button" class="btn btn-primary">Apply</button>
            <button id="closeWatermarkModal" type="button" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>
</div>

</section>


<section id="imageEditorModal-section">
<style>

  .btn-outline-primary {
    transition: 0.3s ease;
  }
  
  .btn-outline-primary:hover {
    background-color: #0d6efd;
    color: #fff;
    transform: translateY(-2px);
  }

  .custom-slider {
    appearance: none; /* Standard property for broader compatibility */
    width: 100%;
    height: 6px;
    border-radius: 5px;
    outline: none;
    transition: background 0.3s ease;
}


  .custom-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #044cb8;
    cursor: pointer;
    box-shadow: 0px 0px 3px rgba(0, 0, 0, 0.2);
  }

  .custom-slider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #044cb8;
    cursor: pointer;
    box-shadow: 0px 0px 3px rgba(0, 0, 0, 0.2);
  }

  #logoImage {
    max-width: 200px;
    height: auto;
    display: block;
    margin: 0 auto;
  }
</style>
<!-- Image Editor Modal -->
<div id="imageEditorModal" class="modal">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header bg-light border-bottom">
          <h5 class="modal-title text-primary">Image Editor</h5>
          <button id="closeImageEditorX" type="button" aria-label="Close" class="close btn-close">×</button>
        </div>
  
        <!-- Editor Controls Section -->
        <div class="modal-body">
  
          <!-- Canvas to display and edit the image -->
          <canvas id="imageCanvas" width="500" height="500"></canvas>
  
          <div class="container-fluid d-flex">
  
            <!-- Logo Upload Section -->
            <div class="card shadow-lg p-4 mb-5 border-0">
                <div class="card-body text-center">
                  <!-- Logo Upload Section -->
                  <label for="uploadLogo" class="form-label fw-bold fs-5">Upload Logo</label>
                  <div class="d-flex justify-content-center mt-3">
                    <input type="file" id="uploadLogo" accept="image/*" class="form-control-file visually-hidden" onchange="previewLogo(this)" />
                    <label for="uploadLogo" class="btn btn-outline-primary px-4 py-2 shadow-sm rounded-pill">
                      <i class="bi bi-upload me-2"></i>Choose Logo
                    </label>
                  </div>
                  <!-- Logo Preview -->
                  <div id="logoPreview" class="mt-4">
                    <img id="logoImage" src="#" alt="Logo Preview" class="img-fluid rounded shadow-sm d-none" />
                  </div>
                  <!-- Logo Size Slider -->
                  <div class="mt-5">
                    <label for="logoSize" class="form-label fw-bold fs-5">Adjust Logo Size</label>
                    <div class="d-flex align-items-center">
                      <span class="small me-2">Small</span>
                      <input type="range" id="logoSize" min="0.1" max="1" step="0.1" value="0.5" class="form-range custom-slider mx-2" />
                      <span class="small ms-2">Large</span>
                    </div>
                  </div>
                </div>
              
  
<script>
    // Show the uploaded logo preview
    function previewLogo(input) {
      const file = input.files[0];
      const reader = new FileReader();
      
      reader.onload = function (e) {
        const logoImage = document.getElementById('logoImage');
        logoImage.src = e.target.result;
        logoImage.classList.remove('d-none');
      };
      
      if (file) {
        reader.readAsDataURL(file);
      }
    }
  </script>
            <!-- Filter Options -->
              <div class="card-body">
                <h5 class="text-secondary fw-bold">Image Filter Adjustments</h5>
                <label for="filters" class="form-label">Select Filter:</label>
                <select id="filters" class="form-select" aria-label="Image filters">
                  <option value="none">None</option>
                  <optgroup label="Color Adjustments">
                    <option value="grayscale">Grayscale</option>
                    <option value="sepia">Sepia</option>
                    <option value="invert">Invert</option>
                    <option value="brightness">Brightness</option>
                    <option value="contrast">Contrast</option>
                    <option value="saturate">Saturation</option>
                    <option value="hue-rotate">Hue Rotate</option>
                  </optgroup>
                  <optgroup label="Effects">
                    <option value="blur">Blur</option>
                    <option value="opacity">Opacity</option>
                    <option value="drop-shadow">Drop Shadow</option>
                  </optgroup>
                  <optgroup label="Transformations">
                    <option value="scale">Scale</option>
                    <option value="skewX">Skew X</option>
                    <option value="skewY">Skew Y</option>
                  </optgroup>
                </select>
              </div>
  
            <!-- Sliders for Adjusting Filters -->
              <div class="card-body">
                <h5 class="text-secondary fw-bold">Adjust Filter Intensity</h5>
                <div id="sliders" class="d-grid gap-3">
                  <!-- Individual filter sliders -->



<div class="d-flex align-items-center">
    <div id="grayscale" class="slider_editor">
        <label for="grayscaleValue" class="me-2">Grayscale:</label>
        <input type="range" id="grayscaleValue" min="0" max="100" value="100">
        <span id="grayscaleOutput" class="ms-2">100%</span>
    </div>
</div>

<div class="d-flex align-items-center">
    <div id="sepia"  class="slider_editor">
        <label for="sepiaValue" class="me-2">Sepia:</label>
        <input type="range" id="sepiaValue" min="0" max="100" value="100">
        <span id="sepiaOutput" class="ms-2">100%</span>
    </div>
</div>


    <div class="d-flex align-items-center">
    <div id="invert"  class="slider_editor">
        <label for="invertValue" class="me-2">Invert:</label>
        <input type="range" id="invertValue" min="0" max="100" value="100">
        <span id="invertOutput" class="ms-2">100%</span>
    </div>
</div>




                  <div class="d-flex align-items-center">
                    <div id="brightness"  class="slider_editor">
                    <label for="brightnessValue" class="me-2">Brightness:</label>
                    <input type="range" id="brightnessValue" min="0" max="200" value="100" class="form-range" />
                    <span id="brightnessOutput" class="ms-2">100%</span>
                </div>
            </div>


                  <div class="d-flex align-items-center">
                    <div id="contrast"  class="slider_editor">
                    <label for="contrastValue" class="me-2">Contrast:</label>
                    <input type="range" id="contrastValue" min="0" max="200" value="100" class="form-range" />
                    <span id="contrastOutput" class="ms-2">100%</span>
                </div>
            </div>
                  
                  <div class="d-flex align-items-center">
                    <div id="saturate"  class="slider_editor">
                    <label for="saturateValue" class="me-2">Saturation:</label>
                    <input type="range" id="saturateValue" min="0" max="200" value="100" class="form-range" />
                    <span id="saturateOutput" class="ms-2">100%</span>
                </div>
            </div>




                <div class="d-flex align-items-center">
                  <div id="hue-rotate"  class="slider_editor">
                    <label for="hueRotateValue" class="me-2">Hue Rotate:</label>
                    <input type="range" id="hueRotateValue" min="0" max="360" value="0">
                    <span id="hueRotateOutput" class="ms-2">0°</span>
                  </div>
                </div>
                <div class="d-flex align-items-center">
                  <div id="blur"  class="slider_editor">
                    <label for="blurValue" class="me-2">Blur:</label>
                    <input type="range" id="blurValue" min="0" max="20" value="0">
                    <span id="blurOutput" class="ms-2">0px</span>
                  </div>
                </div>
                <div class="d-flex align-items-center">
                  <div id="opacity"  class="slider_editor">
                    <label for="opacityValue" class="me-2">Opacity:</label>
                    <input type="range" id="opacityValue" min="0" max="100" value="100">
                    <span id="opacityOutput" class="ms-2">100%</span>
                  </div>
                </div>
                <div class="d-flex align-items-center">
                  <div id="drop-shadow"  class="slider_editor">
                    <label for="dropShadowValue" class="me-2">Drop Shadow (px):</label>
                    <input type="number" id="dropShadowValue" min="0" value="5">
                    <span id="dropShadowOutput" class="ms-2">5px</span>
                  </div>
                </div>
                <div class="d-flex align-items-center">
                  <div id="scale"  class="slider_editor">
                    <label for="scaleValue" class="me-2">Scale:</label>
                    <input type="range" id="scaleValue" min="0.1" max="3" step="0.1" value="1">
                    <span id="scaleOutput" class="ms-2">100%</span>
                  </div>
                </div>
                <div class="d-flex align-items-center">
                  <div id="skewX"  class="slider_editor">
                    <label for="skewXValue" class="me-2">Skew X:</label>
                    <input type="range" id="skewXValue" min="-90" max="90" value="0">
                    <span id="skewXOutput" class="ms-2">0°</span>
                  </div>
                </div>
                <div class="d-flex align-items-center">
                  <div id="skewY"  class="slider_editor">
                    <label for="skewYValue" class="me-2">Skew Y:</label>
                    <input type="range" id="skewYValue" min="-90" max="90" value="0">
                    <span id="skewYOutput" class="ms-2">0°</span>
                  </div>
</div>

                </div>
              </div>
            </div>
  
         
              <div class="d-flex flex-column gap-3 p-3">
  
                <style>
                  .modal-header {
                    background: linear-gradient(45deg, #3f51b5, #1a237e);
                    color: white;
                  }
  
                  .modal-body {
                    background-color: #f8f9fa;
                  }
  
                  .modal-footer {
                    background: linear-gradient(45deg, #495057, #3f51b5);
                  }
  
                  .btn-lg {
                    font-size: 1rem;
                    padding: 0.8rem 1.5rem;
                  }
  
                  .btn-outline-secondary {
                    border: 2px solid #6c757d;
                  }
  
                  .btn-outline-light {
                    color: white;
                    border-color: white;
                  }
  
                  .btn-close-white {
                    filter: invert(100%);
                  }
  
                  .rounded-pill {
                    border-radius: 50rem;
                  }
  
                  .rounded-circle {
                    border-radius: 50%;
                    width: 3rem;
                    height: 3rem;
                  }
  
                  i {
                    font-size: 1.2rem;
                  }
                </style>
         
                  <!-- Filter Buttons Section -->
                  <div class="d-flex justify-content-center mb-4">
                    <button id="saveFilters" class="btn btn-primary btn-lg rounded-pill px-4 me-3" data-bs-toggle="tooltip" data-bs-placement="top" title="Save your current filter settings">
                      <i class="fas fa-save me-2"></i> Save Filters
                    </button>
                    <button id="resetFilters" class="btn btn-danger btn-lg rounded-pill px-4" data-bs-toggle="tooltip" data-bs-placement="top" title="Reset all filters to default">
                      <i class="fas fa-undo-alt me-2"></i> Reset Filters
                    </button>
                  </div>
  
                  <!-- Image Editing Options -->
                  <div class="d-flex justify-content-around align-items-center my-4">
                    <div class="d-flex flex-column align-items-center">
                      <label for="crop" class="fw-semibold mb-2 text-secondary">Crop</label>
                      <button id="cropImage" class="btn btn-outline-secondary rounded-circle p-3" data-bs-toggle="tooltip" data-bs-placement="top" title="Crop the image to your selected dimensions">
                        <i class="fas fa-crop-alt"></i>
                      </button>
                    </div>
                    <div class="d-flex flex-column align-items-center">
                      <label for="resize" class="fw-semibold mb-2 text-secondary">Resize</label>
                      <button id="resizeImage" class="btn btn-outline-secondary rounded-circle p-3" data-bs-toggle="tooltip" data-bs-placement="top" title="Resize the image dimensions">
                        <i class="fas fa-expand-arrows-alt"></i>
                      </button>
                    </div>
                  </div>
                </div>



  
            
          </div>
<!-- End of Flex-->


<div class="modal-footer d-flex justify-content-between px-4 py-3 bg-gradient-secondary">
    <div class="d-flex gap-3">
      <button type="button" class="btn btn-outline-light" id="undoBtn" data-bs-toggle="tooltip" data-bs-placement="top" title="Undo the last action">
        <i class="fas fa-undo"></i> Undo
      </button>
      <button type="button" class="btn btn-outline-light" id="redoBtn" data-bs-toggle="tooltip" data-bs-placement="top" title="Redo the last undone action">
        <i class="fas fa-redo"></i> Redo
      </button>
    </div>
    <div class="d-flex gap-3">
      <button id="saveImage" type="button" class="btn btn-primary btn-lg rounded-pill px-4" data-bs-toggle="tooltip" data-bs-placement="top" title="Save your edited image">
        <i class="fas fa-check-circle me-2"></i> Save
      </button>
      <button id="closeImageEditor" type="button" class="btn btn-outline-light" data-bs-toggle="tooltip" data-bs-placement="top" title="Close the image editor">
        <i class="fas fa-times"></i> Close
      </button>
    </div>
  </div>
</section>


        </div>
  
      </div>
    </div>
  </div>

        </main>
</div>
<div id="currentEventID" class="Hidden" style="display: none;"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/caman/4.1.2/caman.full.min.js"></script>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

    <!-- Footer -->
    <footer id="site-footer">
        <div class="social-icons">
            <!-- Social media links dynamically added here -->
        </div>
        <footer-body>
            <p>&copy; 2024 <a href="./shutterWorx/" style="color: #fff;">ShutterWorx</a>/ TechNoob All Rights Reserved.</p>
            <p><small><a href="privacy" style="color: #fff;">Privacy Policy</a> | <a href="terms" style="color: #fff;">Terms of Service</a></small></p>
        </footer-body>
    </footer>


</body>
    <!-- Include your firebaseConfig.js as a module -->
    <script type="module" defer>
        import {  db, doc,getDoc, query, updateDoc,
    setDoc,     signInWithPopup,
    GoogleAuthProvider,
    FacebookAuthProvider,
    OAuthProvider,
    signOut,
    onAuthStateChanged,
    createUserWithEmailAndPassword,
    signInWithEmailAndPassword,
    where, getDocs, storage, collection, auth, analytics } from '../js/firebaseConfig.js';
  
    /*
     //   const stripe = Stripe("your-publishable-stripe-key");
        firebase.auth().onAuthStateChanged(user => {
   
   
            if (!user) {
        window.location.href = "login.html"; // Redirect to login page
    }
});
*/



    const previewCanvas = document.getElementById("watermarkPreviewCanvas");
    const previewCtx = previewCanvas.getContext("2d");

    console.log(previewCanvas);


        let selectedImages = [];

    const imageUploadArea = document.getElementById("imageUploadArea");
    const imageInput = document.getElementById("imageInput");
    let canvas = document.createElement("canvas");

    const imagePreviewContainer = document.getElementById("imagePreviewContainer");

    // Enable drag-and-drop functionality
    imageUploadArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        imageUploadArea.classList.add("dragging");
    });

    imageUploadArea.addEventListener("dragleave", () => {
        imageUploadArea.classList.remove("dragging");
    });

    imageUploadArea.addEventListener("drop", (e) => {
        e.preventDefault();
        imageUploadArea.classList.remove("dragging");
        handleFiles(e.dataTransfer.files);
    });


    

document.addEventListener("DOMContentLoaded", function () {
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    const tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl);
    });
});


// Main function to handle file uploads
function handleFiles(files) {
    Array.from(files).forEach(file => {
        const fileSize = file.size;
        const fileType = file.type;
        const fileName = file.name;

        const reader = new FileReader();
        reader.onload = e => {
            e.preventDefault();
            processImage(e.target.result, file, fileSize, fileType, fileName);
        };
        reader.readAsDataURL(file);
    });
}

let  ctx, img, logoImg, logoScale = 0.5;  
let filterEffect = "none";
let history = []; // Stack for undo/redo functionality
let redoStack = [];



// Variables for tracking drag status
let isDragging = false;
let offsetX = 0;
let offsetY = 0;
let watermarkPosX = 20; // Default position X
let watermarkPosY = 20; // Default position Y

// Function to create lower-quality image with watermark
async function createLowerQualityImage(dataURL) {
    const img = new Image();
    img.src = dataURL;
    await img.decode();

     canvas = document.createElement("canvas");
    const width = 800;
    const height = (img.height / img.width) * width;
    canvas.width = width;
    canvas.height = height;

     ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, width, height);

    // Add watermark to canvas
    addWatermark(ctx, width, height);

    return canvas.toDataURL("image/jpeg", 0.7); // Compression quality
}

let watermarkSettings = {
    text: "Your Watermark",
    font: "Arial",
    fontSize: 240,
    color: "#000000",
    opacity: 0.5,
    rotation: 0,
    posX: 160,
    posY: 95,
    isBold: true,  // Option for bold text
    isUnderline: false, // Option for underlined text
    shadow: {
        offsetX: 2,
        offsetY: 2,
        blur: 5,
        color: "rgba(0, 0, 0, 0.5)"
    },
    stroke: {
        width: 2,
        color: "#fff"
    }
};
let textX = 0;
let textY = 0;

// Function to add watermark to an image on canvas
function addWatermark(ctx, width, height) {
    const { text, font, fontSize, color, opacity, rotation, isBold, isUnderline, shadow, stroke } = watermarkSettings;

    if (text === "Your Watermark") {
        showToast("Create a Watermark");
        document.getElementById("watermarkSettingsModal").style.display = "block";
        return;
    }

    ctx.save();
    const fontStyle = isBold ? "bold" : "normal";
    ctx.font = `${fontStyle} ${fontSize}px ${font}`;
    ctx.fillStyle = color;
    ctx.globalAlpha = opacity;
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";

    // Calculate zoom level based on canvas dimensions and font size
    const desiredWatermarkWidth = ctx.measureText(text).width;
    const targetWidthRatio = width * 0.5 / desiredWatermarkWidth; // 50% of canvas width as target size
    const targetHeightRatio = height * 0.1 / fontSize; // Adjust based on desired watermark height as % of canvas height
    const zoomLevel = Math.min(targetWidthRatio, targetHeightRatio);

    // Apply scale transformation
    ctx.scale(zoomLevel, zoomLevel);
    // Apply shadow if defined
    if (shadow) {
        ctx.shadowOffsetX = shadow.offsetX;
        ctx.shadowOffsetY = shadow.offsetY;
        ctx.shadowBlur = shadow.blur;
        ctx.shadowColor = shadow.color;
    }

    // Apply stroke settings
    if (stroke) {
        ctx.lineWidth = stroke.width;
        ctx.strokeStyle = stroke.color;
        ctx.lineJoin = "round";
    }

    const textWidth = ctx.measureText(text).width;
    const textHeight = fontSize;

    // Check if multiple watermarks are needed
    if (document.getElementById('multipleWaterMark').checked) {
        const gap = Math.max(textWidth, fontSize) * 1.2; 

// Loop to fill canvas with watermarks
for (let x = 0; x < width + gap; x += gap) {
    for (let y = 0; y < height + gap; y += gap) {

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate((rotation * Math.PI) / 180);

        if (stroke) ctx.strokeText(text, 0, 0);
        ctx.fillText(text, 0, 0);

        ctx.restore();
            }
        }
    } else {
        const centerX = width / 2;
        const centerY = height / 2;
        ctx.translate(centerX, centerY);
        ctx.rotate((rotation * Math.PI) / 180);

        if (stroke) ctx.strokeText(text, -textWidth / 2, textHeight / 2);
        ctx.fillText(text, -textWidth / 2, textHeight / 2);
    }

    // Underline Effect
    if (isUnderline) {
        ctx.beginPath();
        ctx.moveTo(textX, textY + 2);
        ctx.lineTo(textX + textWidth, textY + 2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = color;
        ctx.stroke();
    }

    ctx.restore();

    updateWatermarkPreview();

}




// Function to process image and apply watermark
// Function to process image and apply watermark
async function processImage(dataURL, file, fileSize, fileType, fileName) {
    try {
        // Check if watermark text is set properly before processing
        if (watermarkSettings.text === "Your Watermark") {
            showToast("Create a Watermark");
            document.getElementById("watermarkSettingsModal").style.display = "block";
            return;
        }

        // Create a compressed image with a watermark
        const compressedImage = await createLowerQualityImage(dataURL);

        const imagesData = [
            {
                compressedImage: compressedImage,
                originalUrl: dataURL,
                fileType: fileType,
                fileName: fileName,
                fileSize: fileSize // in bytes
            },
        ];
        
        // Render images
        renderImages(imagesData);

    } catch (error) {
        console.error("Error processing image:", error);
        showToast("Image processing failed.", "error");
    }
}


// Show watermark settings modal
document.getElementById("watermarkSettingsBtn").addEventListener("click", () => {
    loadWatermarkSettings();
    document.getElementById("watermarkSettingsModal").style.display = "block";
});


function resetWatermarkSettings() {
    // Reset each setting to its default
    document.getElementById("watermarkText").value = "Your Watermark";
    document.getElementById("watermarkFont").value = "Arial Black";
    document.getElementById("watermarkSize").value = 240;
    document.getElementById("watermarkColor").value = "#000000";
    document.getElementById("watermarkOpacity").value = 0.5;
    document.getElementById("watermarkRotation").value = 0;
    document.getElementById("watermarkPositionX").value = 160;
    document.getElementById("watermarkPositionY").value = 95;
    document.getElementById("watermarkBold").checked = false;
    document.getElementById("watermarkUnderline").checked = false;
    document.getElementById("watermarkStroke").value = 2;
    document.getElementById("watermarkScale").value = 1.0;
    document.getElementById("multipleWaterMark").checked = false;

    // Call the update function to refresh the preview with default values
    updateWatermarkPreview();
}

function updateWatermarkPreview(reset = false) { 
    if (!previewCtx) return;

    // Clear previous preview
    previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

    // Fetch and validate watermark settings
    const text = document.getElementById("watermarkText").value || "Your Watermark";
    const font = document.getElementById("watermarkFont").value || "Arial Black";
  //  const fontSize = parseInt(document.getElementById("watermarkSize").value, 10) || 240;
    const fontSize = document.getElementById("watermarkSize").value || 240;
    const color = document.getElementById("watermarkColor").value || "#000000";
    const opacity = Math.min(Math.max(parseFloat(document.getElementById("watermarkOpacity").value) || 0.5, 0), 1);
    const rotation = parseInt(document.getElementById("watermarkRotation").value, 10) || 0;
    const isBold = document.getElementById("watermarkBold").checked || false;
    const isUnderline = document.getElementById("watermarkUnderline").checked || false;
    const stroke = document.getElementById("watermarkStroke").value || 2;
    // Get the scale value from the vertical slider
    const zoomLevel =  parseInt(document.getElementById("watermarkScale").value) || 1.0;
/*
    const width = previewCanvas.width;
    const height = previewCanvas.height;
*/
    const width = Math.floor(previewCanvas.width / 2);
    const height = Math.floor(previewCanvas.height / 2);


console.log("zoomLevel  ",zoomLevel);

    previewCtx.save();

       // Apply the zoom scaling
       
    previewCtx.scale(zoomLevel, zoomLevel);

    previewCtx.globalAlpha = opacity;
    previewCtx.font = `${isBold ? "bold" : "normal"} ${fontSize}px ${font}`;
    previewCtx.fillStyle = color;
    previewCtx.textBaseline = "middle";
    previewCtx.textAlign = "center";

    const textWidth = previewCtx.measureText(text).width;
    const gap = Math.max(textWidth, fontSize) * 1.2;  // Adjust multiplier for spacing

    // Check if multiple watermarks are needed
    if (document.getElementById('multipleWaterMark').checked) {
        for (let x = 0; x < width + gap; x += gap) {
            for (let y = 0; y < height + gap; y += gap) {
                previewCtx.save();
                previewCtx.translate(x, y);
                previewCtx.rotate((rotation * Math.PI) / 180);

                if (stroke) {
                    previewCtx.lineWidth = 2;
                    previewCtx.strokeStyle = color;
                    previewCtx.strokeText(text, 0, 0);
                }
                previewCtx.fillText(text, 0, 0);

                previewCtx.restore();
            }
        }
    } else {
        // Draw a single centered watermark
const centerX = Math.floor(width / 2);
const centerY = Math.floor(height / 2);

        previewCtx.translate(centerX, centerY);
        previewCtx.rotate((rotation * Math.PI) / 180);

        if (stroke) {
            previewCtx.lineWidth = 2;
            previewCtx.strokeStyle = color;
            previewCtx.strokeText(text, 0, 0);
        }
        previewCtx.fillText(text, 0, 0);
    }

    // Underline Effect
    if (isUnderline) {
        previewCtx.beginPath();
        previewCtx.moveTo(centerX - textWidth / 2, centerY + fontSize / 2 + 5);
        previewCtx.lineTo(centerX + textWidth / 2, centerY + fontSize / 2 + 5);
        previewCtx.lineWidth = 2;
        previewCtx.strokeStyle = color;
        previewCtx.stroke();
    }

    previewCtx.restore();
}

// Add real-time listeners for all options
document.getElementById("watermarkText").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermarkFont").addEventListener("change", updateWatermarkPreview);
document.getElementById("watermarkSize").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermarkColor").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermarkOpacity").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermarkRotation").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermarkPositionY").addEventListener("input", updateWatermarkPreview);
document.getElementById("watermarkPositionX").addEventListener("input", updateWatermarkPreview);
document.getElementById("multipleWaterMark").addEventListener("change", updateWatermarkPreview);

document.getElementById("watermarkStroke").addEventListener("change", updateWatermarkPreview);
document.getElementById("watermarkBold").addEventListener("click", updateWatermarkPreview);
document.getElementById("watermarkUnderline").addEventListener("click", updateWatermarkPreview);

document.getElementById("watermarkScale").addEventListener("change", updateWatermarkPreview);
// Attach event listener for the reset button
document.getElementById("resetWatermarkSettings").addEventListener("click", resetWatermarkSettings);








// Helper function to get coordinates from touch or mouse event
function getEventPos(event) {
    if (event.touches) {
        // For touch event
        return { x: event.touches[0].clientX, y: event.touches[0].clientY };
    } else {
        // For mouse event
        return { x: event.clientX, y: event.clientY };
    }
}






// Start dragging on mousedown or touchstart
function startDrag(e) {
    const { x, y } = getEventPos(e);
    console.log("x y startDrag Working???    ",x, y);

    // Calculate offset based on current watermark position
    const fontSize = parseInt(document.getElementById("watermarkSize").value) || 240;
    previewCtx.font = `${fontSize}px ${document.getElementById("watermarkFont").value}`;
    const text = document.getElementById("watermarkText").value || "Your Watermark";
    const textWidth = previewCtx.measureText(text).width;

    const watermarkPosY = parseInt(document.getElementById("watermarkPositionY").value, 10) || 95;
    const watermarkPosX = parseInt(document.getElementById("watermarkPositionX").value, 10) || 160;


    if (
        x >= watermarkPosX &&
        x <= watermarkPosX + textWidth * 10 &&
        y >= watermarkPosY - fontSize * 10 &&
        y <= watermarkPosY
        ) {
        isDragging = true; // Only start dragging if within bounds
        offsetX = x - watermarkPosX;
        offsetY = y - watermarkPosY;
        e.preventDefault(); // Prevents scrolling on touch
    } else {
        isDragging = false; // Ensure dragging is false if not within bounds
    }
}

// Dragging logic for mousemove and touchmove
function drag(e) {
    if (isDragging) {
        e.preventDefault(); // Prevents scrolling on touch devices during drag
        const { x, y } = getEventPos(e);
        watermarkPosX = x - offsetX;
        watermarkPosY = y - offsetY;

        console.log("x y drag Working???    ", x, y);

        // Update the input fields for X and Y
        document.getElementById("watermarkPositionX").value = Math.round(watermarkPosX);
        document.getElementById("watermarkPositionY").value = Math.round(watermarkPosY);

        // Update preview
        updateWatermarkPreview();
    }
}



// Stop dragging on mouseup or touchend
function stopDrag() {
    isDragging = false;
}
if (previewCanvas) {

// Mouse events
previewCanvas.addEventListener("mousedown", startDrag);
previewCanvas.addEventListener("mousemove", drag);
previewCanvas.addEventListener("mouseup", stopDrag);
previewCanvas.addEventListener("mouseleave", stopDrag);

// Touch events with passive: false
previewCanvas.addEventListener("touchstart", startDrag, { passive: false });
previewCanvas.addEventListener("touchmove", drag, { passive: false });
previewCanvas.addEventListener("touchend", stopDrag, { passive: false });
previewCanvas.addEventListener("touchcancel", stopDrag, { passive: false });
} else {
    console.error("Preview canvas is not available.");
}

// Close watermark settings modal
function closeWatermarkModal(){
    document.getElementById("watermarkSettingsModal").style.display = "none";
    saveWatermarkSettings();
}

document.getElementById("closeWatermarkX").addEventListener("click", () => {
    closeWatermarkModal();
});

document.getElementById("closeWatermarkModal").addEventListener("click", () => {
    closeWatermarkModal();
});


// Get user settings and apply watermark
function applyWatermarkSettings() {
    console.log("Working???");

    const text = document.getElementById("watermarkText").value || "Your Watermark";
    const font = document.getElementById("watermarkFont").value;
    const fontSize = document.getElementById("watermarkSize").value || 240;
    const color = document.getElementById("watermarkColor").value;
    const opacity = document.getElementById("watermarkOpacity").value;
    const rotation = document.getElementById("watermarkRotation").value || 0;
    const posX = document.getElementById("watermarkPositionX").value || 160;
    const posY = document.getElementById("watermarkPositionY").value || 95;

    // Save settings for use in addWatermark
    watermarkSettings = {
        text,
        font,
        fontSize,
        color,
        opacity,
        rotation,
        posX,
        posY
    };

    closeWatermarkModal();
    showToast("Watermark settings applied!", "success");
}

// Function to remove .card div with a specific data-set-ref value
function removeCardByRef(picCount) {
    // Select all .card elements
    const cards = document.querySelectorAll('.card');

    // Loop through the cards to find the one with the matching data-set-ref attribute
    cards.forEach(card => {
        if (card.getAttribute('data-set-ref') === picCount.toString()) {
            // Remove the card if the data-set-ref matches picCount
            card.remove();
        }
    });
}


let picCount = 1;

// Function to render images
async function renderImages(imagesData) {
    const imagePreviewContainer = document.getElementById("imagePreviewContainer");

    // Clear previous content
   // imagePreviewContainer.innerHTML = "";

    // Assuming imagesData is an array of image objects
    const imageGalleryContainer = document.getElementById("imageGallery");

    // Create a header for the image count
    const imageCountHeader = document.createElement("h5");
    imageCountHeader.innerText = `Total Images: ${picCount = + 1}`;
    imageCountHeader.classList.add("mb-3", "text-left");

    // Clear and add the image count header to the gallery container
    imageGalleryContainer.innerHTML = "";
    imageGalleryContainer.appendChild(imageCountHeader);

    imagesData.forEach((image, index) => {
    const { compressedImage, originalUrl, fileType, fileName, fileSize } = image;

    // Create a new div element for each image card
    const imgDiv = document.createElement("div");
    imgDiv.classList.add("col-md-4", "mt-3");

    // Set the inner HTML with the image details
    imgDiv.innerHTML = `
        <div class="card mb-3" aria-label="Image card for ${fileName}" data-set-ref="${picCount}">
            <img src="${compressedImage}" class="card-img-top img-thumbnail" alt="Compressed version of ${fileName}" loading="lazy">
            <div class="card-body">
                <input type="checkbox" class="select-checkbox" data-set-ref="${picCount}" aria-label="Select image ${fileName}">
                <h6 class="card-title">${truncateText(fileName, 20)}</h6>
                <p class="card-text">
                    Type: ${fileType} <br>
                    Size: ${(fileSize / 1024).toFixed(2)} KB <br>
                    <strong>Image #${picCount}</strong>
                </p>
                <button class="btn btn-primary Edit-Image btn-sm mt-2" aria-label="View full image of ${fileName}" data-original-url="${originalUrl}">
                    Edit Image
                </button>                
                <button class="btn btn-primary Edit-Water-Mark btn-sm mt-2" aria-label="View full image of ${fileName}" data-original-url="${originalUrl}">
                    Remove Card
                </button>
            </div>
        </div>
    `;

    // Append the new image card div to the container without replacing it
    imagePreviewContainer.appendChild(imgDiv);



        // Add an event listener to view the full image on button click
        imgDiv.querySelector("Edit-Image").addEventListener("click", (event) => {
            openImageEditor(event.target.getAttribute("data-original-url"));
        });
        imgDiv.querySelector("Edit-Water-Mark").addEventListener("click", (event) => {
            removeCardByRef(event.target.getAttribute(`data-set-ref`));
        });
    });
}

// Event listener for "Save Selected Images" button with progress tracking
document.getElementById("saveAllImagesBtn").addEventListener("click", async () => {
    const selectedImages = [];

    // Find checked checkboxes and gather corresponding images
    document.querySelectorAll(".select-checkbox:checked").forEach(checkbox => {
        const refIndex = checkbox.dataset.setRef;
        const selectedImage = imagesData[refIndex];
        selectedImages.push(selectedImage);
    });

    console.log("Images selected for saving:", selectedImages);

    // Loop through selectedImages and upload to Firebase with progress tracking
    for (let i = 0; i < selectedImages.length; i++) {
        const { originalUrl, compressedImage, fileName, fileSize, fileType } = selectedImages[i];
        await uploadToFirebase(originalUrl, compressedImage, fileName, fileSize, fileType);

        // Update progress bar
        const progress = ((i + 1) / selectedImages.length) * 100;
        updateProgressBar(progress);
    }
    console.log("Selected images saved successfully.");
});

// Event listener for "Save All Images" button with progress tracking
document.getElementById("saveImagesBtn").addEventListener("click", async () => {
    console.log("Saving all images:", imagesData);

    // Loop through all imagesData and upload to Firebase with progress tracking
    for (let i = 0; i < imagesData.length; i++) {
        const { originalUrl, compressedImage, fileName, fileSize, fileType } = imagesData[i];
        await uploadToFirebase(originalUrl, compressedImage, fileName, fileSize, fileType);

        // Update progress bar
        const progress = ((i + 1) / imagesData.length) * 100;
        updateProgressBar(progress);
    }
    console.log("All images saved successfully.");
});


// Uploads both the original and compressed images to Firebase with metadata
async function uploadToFirebase(originalDataURL, compressedDataURL, fileName, fileSize, fileType) {
    try {
        const eventId = document.getElementById("currentEventID").innerText;
if(!eventId){
    showToast("Error saving images. Create Event First.", "error");
return;

}
        // Convert data URLs to Blobs
        const originalBlob = await (await fetch(originalDataURL)).blob();
        const compressedBlob = await (await fetch(compressedDataURL)).blob();
        const shortenedFileName = cleanAndShortenFileName(fileName, 15);

        // Set Firebase storage references for original and compressed images
        const storageRefOriginal = firebase.storage().ref(`images/${eventId}/${shortenedFileName}`);
        const storageRefCompressed = firebase.storage().ref(`images/${eventId}/${shortenedFileName}`);

        // Upload original image
        const uploadTaskOriginal = storageRefOriginal.put(originalBlob);
        uploadTaskOriginal.on("state_changed", 
            (snapshot) => {
                const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 50; // Show 0-50% for original
                updateProgressBar(progress);
            },
            (error) => {
                console.error("Upload failed:", error);
                showToast("Original image upload failed.", "error");
            },
            async () => {
                const originalURL = await uploadTaskOriginal.snapshot.ref.getDownloadURL();
                
                // Upload compressed image after original is uploaded
                const uploadTaskCompressed = storageRefCompressed.put(compressedBlob);
                uploadTaskCompressed.on("state_changed", 
                    (snapshot) => {
                        const progress = 50 + (snapshot.bytesTransferred / snapshot.totalBytes) * 50; // Show 50-100% for compressed
                        updateProgressBar(progress);
                    },
                    (error) => {
                        console.error("Upload failed:", error);
                        showToast("Compressed image upload failed.", "error");
                    },
                    async () => {
                        const compressedURL = await uploadTaskCompressed.snapshot.ref.getDownloadURL();
                        await saveImageDetails(fileName, originalURL, compressedURL, fileSize, fileType);
                        showToast("Images uploaded successfully!", "success");
                    }
                );
            }
        );
    } catch (error) {
        console.error("Error uploading to Firebase:", error);
        showToast("Error uploading images. Please try again.", "error");
    }
}

// Function to update the progress bar
function updateProgressBar(progress) { 
    const progressBar = document.getElementById("uploadProgress");
    progressBar.style.width = `${progress}%`;
    progressBar.textContent = `${Math.round(progress)}%`;
}



// Saves image details, including metadata, to Firebase Firestore
async function saveImageDetails(fileName, originalUrl, compressedUrl, fileSize, fileType) {
    const title = document.getElementById("eventTitle").value;
    const price = parseFloat(document.getElementById("eventPrice").value);
    const eventId = document.getElementById("currentEventID").innerText;

    if (!eventId && title && !isNaN(price)) {
        try {
            await db.collection("images").add({
                fileName,
                title,
                price,
                originalUrl,
                compressedUrl,
                fileSize, eventID: eventId,
                fileType,  status: "active", isPublic: true,
            });
            showToast("Image details saved successfully!", "success");
        } catch (error) {
            console.error("Error saving image details:", error);
            showToast("Error saving image details. Please try again.", "error");
        }
    } else {
        showToast("Please provide a valid Event ID, title and price.", "warning");
    }
}




// Initialize canvas and context when the image editor is opened
document.getElementById("openImageEditorBtn").addEventListener("click", () => {
    openImageEditor();
});

function openImageEditor(image, compressedImage) {
    document.getElementById("imageEditorModal").style.display = "block";
    canvas = document.getElementById("imageCanvas");
    ctx = canvas.getContext("2d");
    console.log("Working???   openImageEditor");

    loadImage(image, compressedImage);
}

function closeImageEditor() {
    document.getElementById("imageEditorModal").style.display = "none";
}

// Load and draw the original image onto the canvas
function loadImage(image, compressedImage) {
    img = new Image();
    img.src = image; // Replace with dynamic image source
    img.onload = () => {
        saveToHistory(); // Save the initial state
        redrawCanvas(); // Redraw canvas with loaded image
    };
   // console.log("image type... ",img);
}

// Add logo to canvas
function addLogo(event) {
    event.preventDefault;

    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function (e) {
            logoImg = new Image();
            logoImg.src = e.target.result;
            logoImg.onload = () => {
                drawLogo(); // Draw logo once it's loaded
                saveToHistory(); // Save the state after adding a logo
            };
        };
        reader.readAsDataURL(file);
    }
}

function drawLogo() {
    if (logoImg) {
        const logoWidth = logoImg.width * logoScale;
        const logoHeight = logoImg.height * logoScale;
        ctx.drawImage(logoImg, canvas.width - logoWidth - 10, canvas.height - logoHeight - 10, logoWidth, logoHeight);
    }
}

// Update logo size and redraw canvas
function updateLogoSize(event) {
    event.preventDefault();

    logoScale = event.target.value;
    redrawCanvas();
}


function showSlider(event) {
    event.preventDefault();

            const sliders = document.querySelectorAll('.slider_editor');
            sliders.forEach(slider => {
                slider.classList.remove('visible');
            });

            const selectedFilter = event.target.value;
            if (selectedFilter !== 'none') {
                document.getElementById(selectedFilter).classList.add('visible');
            }
        }

        function updateValue(filter, value) {
            const outputId = filter + 'Output';
            const unit = (filter === 'blur' || filter === 'drop-shadow') ? 'px' : (filter === 'hue-rotate') ? '°' : (filter === 'scale') ? '' : '%';
            document.getElementById(outputId).textContent = value + unit;

            // Apply the filter to the image in real-time
            applyFilter(filter, value, unit);
        }

        function applyFilter(filter, value, unit) {
            const image = document.getElementById('targetImage');
            let currentFilters = image.style.filter ? image.style.filter.split(' ') : [];

            // Update filter value or add new one
            const filterValue = `${filter}(${value}${unit})`;
            const filterIndex = currentFilters.findIndex(f => f.startsWith(filter));
            if (filterIndex >= 0) {
                currentFilters[filterIndex] = filterValue; // Update existing filter
            } else {
                currentFilters.push(filterValue); // Add new filter
            }
            image.style.filter = currentFilters.join(' '); // Apply filters to the image
        
        
    redrawCanvas();
        }

        function saveFilters() {
            const image = document.getElementById('targetImage');
            localStorage.setItem('imageFilters', image.style.filter);
            alert('Filters saved!');
        }

        function resetFilters() {
            const sliders = document.querySelectorAll('.slider');
            sliders.forEach(slider => {
                slider.classList.remove('visible');
            });

            document.getElementById('filters').value = 'none'; // Reset filter selection
            const image = document.getElementById('targetImage');
            image.style.filter = ''; // Clear all filters
            alert('Filters reset to default!');
        }

        // Load saved filters from localStorage on page load
        window.onload = () => {
            const savedFilters = localStorage.getItem('imageFilters');
            if (savedFilters) {
                document.getElementById('targetImage').style.filter = savedFilters;
                alert('Loaded saved filters!');
            }
        };



// Save the current canvas state for undo functionality
function saveToHistory() {
    history.push(canvas.toDataURL());
    redoStack = []; // Clear redo stack on new action
}

// Undo functionality
function undo() {
    if (history.length > 0) {
        const lastState = history.pop();
        redoStack.push(canvas.toDataURL());
        const img = new Image();
        img.src = lastState;
        img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            drawLogo(); // Redraw logo
        };
    }
}

// Redo functionality
function redo() {
    if (redoStack.length > 0) {
        const redoState = redoStack.pop();
        history.push(canvas.toDataURL());
        const img = new Image();
        img.src = redoState;
        img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            drawLogo(); // Redraw logo
        };
    }
}

// Redraw the canvas with the current image and logo
function redrawCanvas(img) {
    // Check if img is defined
    if (!img) {
        console.log("Image element is not defined. redrawCanvas");
        return;
    }

    // Create a new canvas and get its context
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
        console.log("Canvas context is not available. redrawCanvas");
        return;
    }

    // Set the canvas size based on the image dimensions
    canvas.width = img.width;
    canvas.height = img.height;

    // Clear the canvas and apply the filter and image
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.filter = filterEffect || "none"; // Apply filter if defined
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    // Draw logo on top, if necessary
    drawLogo(ctx, canvas);  // Assuming `drawLogo` takes ctx as a parameter

    // Reset the filter after drawing
    ctx.filter = "none";

    // Save the current state after redraw
    saveToHistory(canvas); // Assuming `saveToHistory` takes canvas as a parameter
}


// Dynamic cropping functionality
function cropImage() {
    const cropWidth = parseInt(prompt("Enter crop width:", "200")); // User-defined crop width
    const cropHeight = parseInt(prompt("Enter crop height:", "200")); // User-defined crop height
    const cropStartX = parseInt(prompt("Enter crop start X position:", "0")); // User-defined start X
    const cropStartY = parseInt(prompt("Enter crop start Y position:", "0")); // User-defined start Y

    const croppedData = ctx.getImageData(cropStartX, cropStartY, cropWidth, cropHeight);

    // Set canvas to cropped dimensions
    canvas.width = cropWidth;
    canvas.height = cropHeight;
    ctx.putImageData(croppedData, 0, 0);
    drawLogo(); // Redraw logo on cropped image if needed
    saveToHistory(); // Save state after cropping
}

// Resize the image
function resizeImage() {
    const scaleFactor = 0.5; // Example scale factor
    const newWidth = canvas.width * scaleFactor;
    const newHeight = canvas.height * scaleFactor;

    const resizedCanvas = document.createElement("canvas");
    const resizedCtx = resizedCanvas.getContext("2d");

    resizedCanvas.width = newWidth;
    resizedCanvas.height = newHeight;

    resizedCtx.drawImage(canvas, 0, 0, newWidth, newHeight);

    canvas.width = newWidth;
    canvas.height = newHeight;
    ctx.drawImage(resizedCanvas, 0, 0);
    saveToHistory(); // Save state after resizing
}

// Save edited image
function saveImage() {
    const editedImage = canvas.toDataURL("image/png");
    const link = document.createElement("a");
    link.href = editedImage;
    link.download = "edited-image.png";
    link.click();
}




// Wait for the document to fully load
document.addEventListener("DOMContentLoaded", function () {
// Initialize preview on load
updateWatermarkPreview();

// Bind undo/redo buttons
document.getElementById("undoBtn").addEventListener("click", undo);
document.getElementById("redoBtn").addEventListener("click", redo);


document.getElementById("saveFilters").addEventListener("click", saveFilters);
document.getElementById("resizeImage").addEventListener("click", resizeImage);
document.getElementById("cropImage").addEventListener("click", cropImage);

document.getElementById("saveImage").addEventListener("click", saveImage);
document.getElementById("closeImageEditorX").addEventListener("click", closeImageEditor);
document.getElementById("closeImageEditor").addEventListener("click", closeImageEditor);

document.getElementById("redoBtn").addEventListener("click", redo);





// Image Upload Click Listener (to trigger file input)
document.getElementById("imageUploadArea").addEventListener("click", function() {
    document.getElementById("imageInput").click();
});


    // Assuming your HTML has an <input> element with id="imageInput"
document.getElementById("imageInput").addEventListener("change", function() {
    handleFiles(this.files);
});



//document.getElementById("openImageEditorBtn").addEventListener("click", openImageEditor);

// Event Form Button Listener
document.getElementById("saveEvent").addEventListener("click", saveEvent);

// Event Listeners for Watermark Modal Buttons
document.getElementById("applyWatermarkSettings").addEventListener("click", applyWatermarkSettings);

// Event Listener for the Image Editor Close Button
document.querySelector("#imageEditorModal .modal-header .close").addEventListener("click", closeImageEditor);



document.querySelectorAll(".slider input[type='range']").forEach(slider => {
    slider.addEventListener("input", function() {
        const sliderValueId = slider.id;
        const outputId = `${sliderValueId.replace("Value", "Output")}`;
        const outputElement = document.getElementById(outputId);

        // Update output display
        outputElement.textContent = `${slider.value}${sliderValueId.includes("scale") ? '%' : sliderValueId.includes("rotate") || sliderValueId.includes("skew") ? '°' : sliderValueId.includes("blur") ? 'px' : '%'}`;
        
        // Call updateValue to apply the actual filter if needed
        updateValue(sliderValueId.replace("Value", ""), slider.value);
    });
});

// Additional function to handle filter application (modify as needed)
function updateValue(filterType, value) {
    const targetImage = document.getElementById("targetImage"); // Adjust ID to match your image element
    
    // Initialize filter styles array
    let filters = [];

    // Apply filters based on filter type
    if (filterType === "grayscale") {
        filters.push(`grayscale(${value}%)`);
    } else if (filterType === "sepia") {
        filters.push(`sepia(${value}%)`);
    } else if (filterType === "invert") {
        filters.push(`invert(${value}%)`);
    } else if (filterType === "brightness") {
        filters.push(`brightness(${value}%)`);
    } else if (filterType === "contrast") {
        filters.push(`contrast(${value}%)`);
    } else if (filterType === "saturate") {
        filters.push(`saturate(${value}%)`);
    } else if (filterType === "hue-rotate") {
        filters.push(`hue-rotate(${value}deg)`);
    } else if (filterType === "blur") {
        filters.push(`blur(${value}px)`);
    } else if (filterType === "opacity") {
        filters.push(`opacity(${value}%)`);
    } else if (filterType === "drop-shadow") {
        filters.push(`drop-shadow(0px 0px ${value}px rgba(0, 0, 0, 0.5))`);
    }

    // Apply transform styles based on filter type
    if (filterType === "scale") {
        targetImage.style.transform = `scale(${value})`;
    } else if (filterType === "skewX") {
        targetImage.style.transform = `skewX(${value}deg)`;
    } else if (filterType === "skewY") {
        targetImage.style.transform = `skewY(${value}deg)`;
    }

    // Combine all filters and apply them to the image
    targetImage.style.filter = filters.join(" ");
}


// Logo Upload and Size Update
document.getElementById("uploadLogo").addEventListener("change", addLogo);
document.getElementById("logoSize").addEventListener("input", updateLogoSize(event));

// Filter dropdown
document.getElementById("filters").addEventListener("change", showSlider(event));
});


function saveEvent() {
            const title = document.getElementById('eventTitle').value;
            const date = document.getElementById('eventDate').value;
            const description = document.getElementById('eventDescription').value;
            const price = parseFloat(document.getElementById('eventPrice').value);
            const location = document.getElementById("eventLocation").value;
            const accessCode = document.getElementById("accessCode").value;
            const eventIdArea = document.getElementById("currentEventID");

            if (title && date && description && !isNaN(price)) {
    db.collection('events').add({
        title,
        date,
        description,
        status: "active",
        isPublic: true,
        price,
        accessCode,
        location,
    }).then((docRef) => { // Use docRef to get the ID
        eventIdArea.innerText = docRef.id; // Retrieve the document ID

        showToast("Event saved successfully!");
    }).catch(error => {
        console.error("Error saving event:", error);
        showToast("An error occurred while saving the event. Please try again.");
    });
} else {
    showToast("Please fill in all fields.");
}

        }


        function saveWatermarkSettings() {
    const watermarkSettings = {};

    // Gather values from each input field
    document.querySelectorAll("#watermarkSettingsModal input, #watermarkSettingsModal select").forEach(input => {
        if (input.type === "checkbox") {
            watermarkSettings[input.id] = input.checked; // Save checked state for checkboxes
        } else {
            watermarkSettings[input.id] = input.value; // Save value for other types
        }
    });

    // Save settings to localStorage
    localStorage.setItem("watermarkSettings", JSON.stringify(watermarkSettings));
}

// Attach save function to a button or event, e.g., "Apply" button click
//document.getElementById("applyWatermarkSettings").addEventListener("click", saveWatermarkSettings);

function loadWatermarkSettings() {
    const savedSettings = localStorage.getItem("watermarkSettings");

    if (savedSettings) {
        const watermarkSettings = JSON.parse(savedSettings); // Parse JSON back into an object

        // Iterate over each saved setting and apply it to the corresponding input field
        Object.keys(watermarkSettings).forEach(key => {
            const input = document.getElementById(key);

            if (input) {
                if (input.type === "checkbox") {
                    input.checked = watermarkSettings[key]; // Set checked state for checkboxes
                } else {
                    input.value = watermarkSettings[key]; // Set value for other types of inputs
                }
            }
        });

        //  load Saved 
updateWatermarkPreview();
    }
}

// Call this function on page load or when opening the modal
document.addEventListener("DOMContentLoaded", loadWatermarkSettings);




    </script>
  
  <script  type="module" src="../js/main.js"></script>
  <script  type="module" src="../js/admin.js"></script>


</html>